#!/usr/bin/env python3

import sys
import importlib
import tempfile
import zipfile
from pathlib import Path
from shutil import rmtree
from typing import List, Dict, Any

import os.path
from os import chdir

try:
    from pxr import *
    import usdUtils
except ImportError:
    print(
        '  \033[91mError: failed to import pxr module. Please add path to USD Python bindings to your PYTHONPATH\033[0m'
    )
    usdLibLoaded = False
else:
    usdLibLoaded = True

__all__ = ['convert']

kConvertErrorReturnValue = 2


class USDParameters:
    version: float = 0.66
    materialsPath: str = '/Materials'

    def __init__(
        self,
        usdStage: Usd.Stage,
        verbose: bool,
        url: str,
        creator: str,
        copyright: str,
        assetPath: str,
    ) -> None:
        self.usdStage = usdStage
        self.verbose = verbose
        self.url = url
        self.creator = creator
        self.copyright = copyright
        self.usdMaterials: Dict[str, UsdShade.Material] = {}
        self.usdMaterialsByName: Dict[str, UsdShade.Material] = {}
        self.defaultMaterial: UsdShade.Material | None = None
        self.assetName: str = ''
        self.asset = usdUtils.Asset(assetPath, usdStage)


class ParserOut:
    def __init__(self) -> None:
        self.inFilePath: str = ''
        self.outFilePath: str = ''
        self.argumentFile: str = ''
        self.materials: List[usdUtils.Material] = []
        self.verbose: bool = False
        self.copyTextures: bool = False
        self.iOS12: bool = False
        self.paths: List[str] | None = None
        self.url: str = ''
        self.creator: str = ''
        self.copyright: str = ''
        self.metersPerUnit: float = 0.0
        self.preferredIblVersion: int = -1
        self.loop: bool = False
        self.noloop: bool = False
        self.useObjMtl: bool = False
        material = usdUtils.Material('')
        self.materials.append(material)


class OpenParameters:
    def __init__(self) -> None:
        self.copyTextures: bool = False
        self.searchPaths: List[str] | None = None
        self.verbose: bool = False
        self.metersPerUnit: float = 0.0


class Parser:
    def __init__(self) -> None:
        self.out = ParserOut()
        self.arguments: List[str] = []
        self.argumentIndex: int = 0
        self.texCoordSet: str = 'st'
        self.wrapS: str = usdUtils.WrapMode.useMetadata
        self.wrapT: str = usdUtils.WrapMode.useMetadata

    def printConvertNameAndVersion(self) -> None:
        print(f'usdzconvert {USDParameters.version}')

    def printUsage(self) -> None:
        self.printConvertNameAndVersion()
        usage_text = (
            'usage: usdzconvert inputFile [outputFile]\n'
            '       [-h] [-version] [-f file] [-v]\n'
            '       [-path path[+path2[...]]]\n'
            '       [-url url]\n'
            '       [-copyright copyright]\n'
            '       [-copytextures]\n'
            '       [-metersPerUnit value]\n'
            '       [-useObjMtl]\n'
            '       [-preferredIblVersion value]\n'
            '       [-loop]\n'
            '       [-no-loop]\n'
            '       [-iOS12]\n'
            '       [-m materialName]\n'
            '       [-texCoordSet name]\n'
            '       [-wrapS mode]\n'
            '       [-wrapT mode]\n'
            '       [-diffuseColor           r,g,b]\n'
            '       [-diffuseColor           <file> fr,fg,fb]\n'
            '       [-normal                 x,y,z]\n'
            '       [-normal                 <file> fx,fy,fz]\n'
            '       [-emissiveColor          r,g,b]\n'
            '       [-emissiveColor          <file> fr,fb,fg]\n'
            '       [-metallic               c]\n'
            '       [-metallic               ch <file> fc]\n'
            '       [-roughness              c]\n'
            '       [-roughness              ch <file> fc]\n'
            '       [-occlusion              c]\n'
            '       [-occlusion              ch <file> fc]\n'
            '       [-opacity                c]\n'
            '       [-opacity                ch <file> fc]\n'
            '       [-clearcoat              c]\n'
            '       [-clearcoat              ch <file> fc]\n'
            '       [-clearcoatRoughness     c]\n'
            '       [-clearcoatRoughness     ch <file> fc]\n'
        )
        print(usage_text)

    def printHelpAndExit(self) -> None:
        self.printUsage()
        help_file_path = Path(sys.path[0]) / 'help.txt'
        try:
            with open(help_file_path, 'r') as file:
                print(file.read())
        except FileNotFoundError:
            print(f'Help file not found at {help_file_path}')
        raise usdUtils.ConvertExit()

    def printVersionAndExit(self) -> None:
        print(USDParameters.version)
        raise usdUtils.ConvertExit()

    def printErrorUsageAndExit(self, message: str) -> None:
        self.printConvertNameAndVersion()
        usdUtils.printError(message)
        print('For more information, run "usdzconvert -h"')
        raise usdUtils.ConvertError()

    def loadArgumentsFromFile(self, filename: str) -> None:
        self.out.argumentFile = ''
        file_path = Path(filename)
        if not file_path.is_absolute() and self.out.inFilePath:
            file_path = Path(os.path.dirname(self.out.inFilePath)) / file_path

        if file_path.is_file():
            self.out.argumentFile = str(file_path)
        else:
            self.printErrorUsageAndExit(f"failed to load argument file: {filename}")

        with open(file_path, 'r') as file:
            for line in file:
                line = line.strip()
                if not line:
                    continue

                line = line.replace('\t', ' ').replace(',', ' ')
                quotes = line.split('"')
                if len(quotes) > 1:
                    for i in range(1, len(quotes), 2):
                        quotes[i] = quotes[i].replace(' ', '\t')
                    line = ''.join(quotes)

                arguments = line.split(' ')
                for argument in arguments:
                    argument = argument.replace('\t', ' ').strip()
                    if argument:
                        self.arguments.append(argument)

    def getParameters(self, count: int, argument: str) -> Any:
        if self.argumentIndex + count >= len(self.arguments):
            self.printErrorUsageAndExit(f'argument {argument} needs more parameters')

        self.argumentIndex += count
        if count == 1:
            parameter = self.arguments[self.argumentIndex]
            if parameter.startswith('-') and not isFloat(parameter):
                self.printErrorUsageAndExit(
                    f'unexpected parameter {parameter} for argument {argument}'
                )
            return self.arguments[self.argumentIndex]
        else:
            parameters = self.arguments[(self.argumentIndex - count + 1) : (self.argumentIndex + 1)]
            for parameter in parameters:
                if parameter.startswith('-') and not isFloat(parameter):
                    self.printErrorUsageAndExit(
                        f'unexpected parameter {parameter} for argument {argument}'
                    )
            return parameters

    def isNextArgumentsAreFloats(self, count: int) -> bool:
        if self.argumentIndex + count >= len(self.arguments):
            return False
        for i in range(count):
            argument = self.arguments[self.argumentIndex + 1 + i]
            if not isFloat(argument):
                return False
        return True

    def processInputArgument(self, argument: str) -> int:
        Ok = 0
        Error = 1
        inputIdx = -1
        for i, inputName in enumerate(usdUtils.Input.names):
            if f'-{inputName}' == argument:
                inputIdx = i
                break
        if inputIdx == -1:
            return Error

        defaultChannels = usdUtils.Input.channels[inputIdx]
        channelsCount = len(defaultChannels)
        inputName = usdUtils.Input.names[inputIdx]
        if self.isNextArgumentsAreFloats(channelsCount):
            # constant or RGB value for input
            self.out.materials[-1].inputs[inputName] = self.getParameters(channelsCount, argument)
            return Ok

        # texture file
        channels = ''
        filename = ''
        parameter = self.getParameters(1, argument)
        if parameter in {'r', 'g', 'b', 'a', 'rgb'}:
            channels = parameter
            filename = self.getParameters(1, argument)
        else:
            filename = parameter

        if (channelsCount != 1 and channels) or channels == 'rgb':
            usdUtils.printWarning(f'invalid channel {channels} for argument {argument}')
            channels = ''

        fallback = None
        if self.isNextArgumentsAreFloats(channelsCount):
            fallback = self.getParameters(channelsCount, argument)

        if not channels:
            index = usdUtils.Input.names.index(inputName)
            channels = usdUtils.Input.channels[index]

        self.out.materials[-1].inputs[inputName] = usdUtils.Map(
            channels, filename, fallback, self.texCoordSet, self.wrapS, self.wrapT
        )
        return Ok

    def processPath(self, pathLine: str) -> List[str]:
        paths = pathLine.split('+')
        outPath = []
        for path in paths:
            if path:
                if Path(path).is_dir():
                    outPath.append(path)
                else:
                    usdUtils.printWarning(f"Folder '{path}' does not exist. Ignored.")
        return outPath

    def parse(self, arguments: List[str]) -> ParserOut:
        self.arguments = []
        for arg in arguments:
            if ',' in arg:
                newargs = list(filter(None, arg.replace(',', ' ').split(' ')))
                self.arguments.extend(newargs)
            else:
                self.arguments.append(arg)

        if not arguments:
            self.printUsage()
            print('For more information, run "usdzconvert -h"')
            raise usdUtils.ConvertExit()

        while self.argumentIndex < len(self.arguments):
            argument = self.arguments[self.argumentIndex]
            if not argument:
                self.argumentIndex += 1
                continue
            if argument.startswith('-'):
                # parse optional arguments
                if argument == '-v':
                    self.out.verbose = True
                elif argument == '-copytextures':
                    self.out.copyTextures = True
                elif argument.lower() == '-ios12':
                    self.out.iOS12 = True
                elif argument == '-path':
                    self.out.paths = self.processPath(self.getParameters(1, argument))
                elif argument == '-copyright':
                    self.out.copyright = self.getParameters(1, argument)
                elif argument == '-url':
                    self.out.url = self.getParameters(1, argument)
                elif argument == '-creator':
                    self.out.creator = self.getParameters(1, argument)
                elif argument == '-metersPerUnit':
                    metersPerUnit = self.getParameters(1, argument)
                    if not isFloat(metersPerUnit) or float(metersPerUnit) <= 0:
                        self.printErrorUsageAndExit(
                            f'expected positive float value for argument {argument}'
                        )
                    self.out.metersPerUnit = float(metersPerUnit)
                elif argument in {'-preferredIblVersion', '--preferredIblVersion', '--preferrediblversion'}:
                    preferredIblVersion = self.getParameters(1, argument)
                    if (
                        not isFloat(preferredIblVersion)
                        or float(preferredIblVersion) < 0
                        or float(preferredIblVersion) > 2
                    ):
                        self.printErrorUsageAndExit(
                            f'expected positive integer value [0, 1, 2] for argument {argument}'
                        )
                    self.out.preferredIblVersion = int(float(preferredIblVersion))
                elif argument == '-m':
                    name = self.getParameters(1, argument)
                    material = usdUtils.Material(name)
                    self.out.materials.append(material)
                    self.texCoordSet = 'st'  # reset to default
                elif argument == '-texCoordSet':
                    self.texCoordSet = self.getParameters(1, argument)
                elif argument.lower() == '-wraps':
                    wrap_mode = self.getParameters(1, argument)
                    if not usdUtils.isWrapModeCorrect(wrap_mode):
                        self.printErrorUsageAndExit(
                            f"wrap mode '{wrap_mode}' is incorrect for {argument}"
                        )
                    self.wrapS = wrap_mode
                elif argument.lower() == '-wrapt':
                    wrap_mode = self.getParameters(1, argument)
                    if not usdUtils.isWrapModeCorrect(wrap_mode):
                        self.printErrorUsageAndExit(
                            f"wrap mode '{wrap_mode}' is incorrect for {argument}"
                        )
                    self.wrapT = wrap_mode
                elif argument in {'-loop', '--loop'}:
                    self.out.loop = True
                elif argument in {'-no-loop', '--no-loop'}:
                    self.out.noloop = True
                elif argument == '-useObjMtl':
                    self.out.useObjMtl = True
                elif argument in {'-h', '--help'}:
                    self.printHelpAndExit()
                elif argument in {'-version', '--version'}:
                    self.printVersionAndExit()
                elif argument == '-f':
                    self.loadArgumentsFromFile(self.getParameters(1, argument))
                else:
                    errorValue = self.processInputArgument(argument)
                    if errorValue:
                        self.printErrorUsageAndExit(f'unknown argument {argument}')
            else:
                # parse input/output filenames
                if not self.out.inFilePath:
                    self.out.inFilePath = argument
                elif not self.out.outFilePath:
                    self.out.outFilePath = argument
                else:
                    print(f'Input file: {self.out.inFilePath}')
                    print(f'Output file: {self.out.outFilePath}')
                    self.printErrorUsageAndExit(f'unknown argument {argument}')

            self.argumentIndex += 1

        if not self.out.inFilePath:
            self.printErrorUsageAndExit('too few arguments')

        if self.out.loop and self.out.noloop:
            self.printErrorUsageAndExit("can't use -loop and -no-loop flags together")

        return self.out


def isFloat(value: str) -> bool:
    try:
        float(value)
        return True
    except ValueError:
        return False


def createMaterial(params: USDParameters, materialName: str) -> UsdShade.Material:
    matPath = f'{params.materialsPath}/{materialName}'

    if params.verbose:
        print(f'  creating material at path: {matPath}')
    if not Sdf.Path.IsValidIdentifier(materialName):
        usdUtils.printError("failed to create material by specified path.")
        raise usdUtils.ConvertError()

    surfaceShader = UsdShade.Shader.Define(params.usdStage, f'{matPath}/Shader')
    surfaceShader.CreateIdAttr('UsdPreviewSurface')
    surfaceOutput = surfaceShader.CreateOutput('surface', Sdf.ValueTypeNames.Token)
    usdMaterial = UsdShade.Material.Define(params.usdStage, matPath)
    usdMaterial.CreateOutput('surface', Sdf.ValueTypeNames.Token).ConnectToSource(surfaceOutput)

    params.usdMaterials[matPath] = usdMaterial
    params.usdMaterialsByName[materialName] = usdMaterial
    return usdMaterial


def getAllUsdMaterials(params: USDParameters, usdParentPrim: Usd.Prim) -> None:
    for usdPrim in usdParentPrim.GetChildren():
        if usdPrim.IsA(UsdGeom.Mesh) or usdPrim.IsA(UsdGeom.Subset):
            bindAPI = UsdShade.MaterialBindingAPI(usdPrim)
            if bindAPI:
                usdShadeMaterial = None
                directBinding = bindAPI.GetDirectBinding()
                matPath = str(directBinding.GetMaterialPath())

                if matPath:
                    if params.usdStage.GetObjectAtPath(matPath).IsValid():
                        usdShadeMaterial = directBinding.GetMaterial()
                    elif params.verbose:
                        usdUtils.printWarning(
                            f"Mesh has material '{matPath}' which does not exist."
                        )

                if usdShadeMaterial and matPath not in params.usdMaterials:
                    params.usdMaterials[matPath] = usdShadeMaterial
                    materialName = Path(matPath).name
                    params.usdMaterialsByName[materialName] = usdShadeMaterial

        getAllUsdMaterials(params, usdPrim)


def addDefaultMaterialToGeometries(params: USDParameters, usdParentPrim: Usd.Prim) -> None:
    for usdPrim in usdParentPrim.GetChildren():
        if usdPrim.IsA(UsdGeom.Mesh) or usdPrim.IsA(UsdGeom.Subset):
            bindAPI = UsdShade.MaterialBindingAPI(usdPrim)
            if bindAPI:
                usdShadeMaterial = None
                directBinding = bindAPI.GetDirectBinding()
                matPath = str(directBinding.GetMaterialPath())

                if matPath:
                    usdShadeMaterial = directBinding.GetMaterial()

                if not usdShadeMaterial:
                    if not params.defaultMaterial:
                        params.defaultMaterial = createMaterial(params, 'defaultMaterial')
                    matPath = f'{params.materialsPath}/defaultMaterial'
                    usdShadeMaterial = params.defaultMaterial
                    bindAPI.Bind(usdShadeMaterial)

                if matPath not in params.usdMaterials:
                    params.usdMaterials[matPath] = usdShadeMaterial
                    materialName = Path(matPath).name
                    params.usdMaterialsByName[materialName] = usdShadeMaterial

        addDefaultMaterialToGeometries(params, usdPrim)


def findUsdMaterialRecursively(
    params: USDParameters, usdParentPrim: Usd.Prim, name: str, byPath: bool
) -> UsdShade.Material | None:
    for usdPrim in usdParentPrim.GetChildren():
        if usdPrim.IsA(UsdShade.Material):
            path = usdPrim.GetPath()
            if byPath:
                if path == name:
                    return UsdShade.Material(usdPrim)
            else:
                matName = Path(str(path)).name
                if matName == name:
                    return UsdShade.Material(usdPrim)
        usdMaterial = findUsdMaterialRecursively(params, usdPrim, name, byPath)
        if usdMaterial:
            return usdMaterial
    return None


def findUsdMaterial(params: USDParameters, name: str) -> UsdShade.Material | None:
    if not name:
        return None

    # First try to find by material path
    if name in params.usdMaterials:
        return params.usdMaterials[name]

    # Try to find by material name
    materialName = usdUtils.makeValidIdentifier(name)
    if materialName in params.usdMaterialsByName:
        return params.usdMaterialsByName[materialName]

    # Try other options
    testMaterialName = f'/Materials/{materialName}'
    if testMaterialName in params.usdMaterials:
        return params.usdMaterials[testMaterialName]

    testMaterialName = f'/{materialName}'
    if testMaterialName in params.usdMaterials:
        return params.usdMaterials[testMaterialName]

    byPath = name.startswith('/')
    return findUsdMaterialRecursively(params, params.usdStage.GetPseudoRoot(), name, byPath)


def copyTexturesFromStageToFolder(params: USDParameters, srcPath: str, folder: str) -> None:
    copiedFiles = {}
    srcFolder = Path(srcPath).parent
    folderPath = Path(folder)

    for path, usdMaterial in params.usdMaterials.items():
        for childShader in usdMaterial.GetPrim().GetChildren():
            idAttribute = childShader.GetAttribute('info:id')
            if not idAttribute:
                continue
            id = idAttribute.Get()
            if id != 'UsdUVTexture':
                continue
            fileAttribute = childShader.GetAttribute('inputs:file')
            if not fileAttribute or not fileAttribute.Get():
                continue
            filename = fileAttribute.Get().path
            if not filename or filename in copiedFiles:
                continue
            filePath = srcFolder / filename if not Path(filename).is_absolute() else Path(filename)
            if filePath.is_file():
                usdUtils.copy(str(filePath), str(folderPath / filename), params.verbose)
                copiedFiles[filename] = filename


def copyMaterialTextures(
    params: USDParameters, material: usdUtils.Material, srcPath: str, dstPath: str, folder: str
) -> None:
    srcFolder = Path(srcPath).parent
    dstFolder = Path(dstPath).parent if dstPath else None
    folderPath = Path(folder)

    for inputName, input in material.inputs.items():
        if not isinstance(input, usdUtils.Map):
            continue
        if not input.file:
            continue

        file_obj = Path(input.file)
        copied = False

        if srcFolder and (srcFolder / file_obj).is_file():
            usdUtils.copy(str(srcFolder / file_obj), str(folderPath / file_obj), params.verbose)
            copied = True
        elif dstFolder and (dstFolder / file_obj).is_file():
            usdUtils.copy(str(dstFolder / file_obj), str(folderPath / file_obj), params.verbose)
            copied = True
        elif file_obj.is_file():
            if srcFolder and str(srcFolder) in str(file_obj):
                relative_path = file_obj.relative_to(srcFolder)
                usdUtils.copy(str(srcFolder / relative_path), str(folderPath / relative_path), params.verbose)
                input.file = str(relative_path)
                copied = True
            elif dstFolder and str(dstFolder) in str(file_obj):
                relative_path = file_obj.relative_to(dstFolder)
                usdUtils.copy(str(dstFolder / relative_path), str(folderPath / relative_path), params.verbose)
                input.file = str(relative_path)
                copied = True
            else:
                basename = f'textures/{file_obj.name}'
                usdUtils.copy(str(file_obj), str(folderPath / basename), params.verbose)
                input.file = basename
                copied = True

        if not copied:
            usdUtils.printWarning(f"Failed to copy texture file: {input.file}")


def createStageMetadata(params: USDParameters) -> None:
    if params.creator:
        params.usdStage.SetMetadataByDictKey("customLayerData", "creator", str(params.creator))
    else:
        params.usdStage.SetMetadataByDictKey(
            "customLayerData", "creator", f"usdzconvert preview {params.version}"
        )
    if params.url:
        params.usdStage.SetMetadataByDictKey("customLayerData", "url", str(params.url))
    if params.copyright:
        params.usdStage.SetMetadataByDictKey("customLayerData", "copyright", str(params.copyright))


def unzip(filePath: str, outputDir: str) -> str:
    firstFile = ''
    with zipfile.ZipFile(filePath, 'r') as zf:
        zf.extractall(outputDir)
        namelist = zf.namelist()
        if namelist:
            firstFile = namelist[0]
    return firstFile


def process(argumentList: List[str]) -> int:
    parser = Parser()
    parserOut = parser.parse(argumentList)

    srcPath = ''
    inFile = Path(parserOut.inFilePath)
    if inFile.is_file():
        srcPath = str(inFile)
    elif not inFile.parent and parserOut.argumentFile:
        argumentFileDir = Path(parserOut.argumentFile).parent
        os.chdir(argumentFileDir)
        if inFile.is_file():
            srcPath = str(inFile)

    if not srcPath:
        parser.printErrorUsageAndExit(f'input file {parserOut.inFilePath} does not exist.')

    fileAndExt = inFile.suffix
    if not fileAndExt:
        parser.printErrorUsageAndExit(
            f'input file {parserOut.inFilePath} has unsupported file extension.'
        )

    print(f'Input file: {srcPath}')
    srcExt = fileAndExt.lower()

    dstIsUsdz = False
    dstPath = Path(parserOut.outFilePath) if parserOut.outFilePath else Path(inFile.with_suffix('.usdz'))
    dstExt = dstPath.suffix.lower()

    if not dstPath.suffix:
        dstPath = dstPath.with_suffix('.usdz')
        dstIsUsdz = True
    elif dstExt == '.usdz':
        dstIsUsdz = True
    elif dstExt not in {'.usd', '.usdc', '.usda'}:
        parser.printErrorUsageAndExit(
            f'output file {dstPath} should have .usdz, .usdc, .usda or .usd extension.'
        )

    tmpFolder = tempfile.mkdtemp(prefix='usdzconvert')

    legacyModifier = None
    if parserOut.iOS12:
        iOS12Compatible_module = importlib.import_module("iOS12LegacyModifier")
        legacyModifier = iOS12Compatible_module.createLegacyModifier()
        print('Converting in iOS12 compatibility mode.')

    tmpPath = Path(tmpFolder) / (dstPath.with_suffix('.usdc').name if dstIsUsdz else dstPath.name)

    if parserOut.verbose and parserOut.copyTextures and dstIsUsdz:
        usdUtils.printWarning(
            'argument -copytextures works for .usda and .usdc output files only.'
        )

    openParameters = OpenParameters()
    openParameters.copyTextures = parserOut.copyTextures and not dstIsUsdz
    openParameters.searchPaths = parserOut.paths
    openParameters.verbose = parserOut.verbose

    srcIsUsd = False
    srcIsUsdz = False
    usdStage = None

    if srcExt == '.obj':
        usdStageWithObj_module = importlib.import_module("usdStageWithObj")
        usdStage = usdStageWithObj_module.usdStageWithObj(
            srcPath, str(tmpPath), parserOut.useObjMtl, openParameters
        )
    elif srcExt in {'.gltf', '.glb'}:
        usdStageWithGlTF_module = importlib.import_module("usdStageWithGlTF")
        usdStage = usdStageWithGlTF_module.usdStageWithGlTF(
            srcPath, str(tmpPath), legacyModifier, openParameters
        )
    elif srcExt == '.fbx':
        usdStageWithFbx_module = importlib.import_module("usdStageWithFbx")
        usdStage = usdStageWithFbx_module.usdStageWithFbx(
            srcPath, str(tmpPath), legacyModifier, openParameters
        )
    elif srcExt in {'.usd', '.usda', '.usdc'}:
        usdStage = Usd.Stage.Open(srcPath)
        srcIsUsd = True
        openParameters.metersPerUnit = usdStage.GetMetadata("metersPerUnit")
    elif srcExt == '.usdz':
        tmpUSDC = unzip(srcPath, tmpFolder)
        if not tmpUSDC:
            parser.printErrorUsageAndExit(f"can't open input usdz file {parserOut.inFilePath}")
        usdStage = Usd.Stage.Open(Path(tmpFolder) / tmpUSDC)
        srcIsUsdz = True
    elif srcExt == '.abc':
        usdStage = Usd.Stage.Open(srcPath)
        # To update Alembic USD Stage, first save it to temporary .usdc and reload it
        tmpUSDC = str(tmpPath) + '.usdc'
        usdStage.GetRootLayer().Export(tmpUSDC)
        if parserOut.verbose:
            print(f'Temporary USDC file: {tmpUSDC}')
        usdStage = Usd.Stage.Open(tmpUSDC)
    else:
        parser.printErrorUsageAndExit(
            f'input file {parserOut.inFilePath} has unsupported file extension.'
        )

    if not usdStage:
        usdUtils.printError("failed to create USD stage.")
        raise usdUtils.ConvertError()

    params = USDParameters(
        usdStage,
        parserOut.verbose,
        parserOut.url,
        parserOut.creator,
        parserOut.copyright,
        str(tmpPath),
    )
    createStageMetadata(params)

    if parserOut.loop and srcIsUsd or srcIsUsdz:
        usdStage.SetMetadataByDictKey("customLayerData", "loopStartToEndTimeCode", True)

    if parserOut.noloop:
        usdStage.SetMetadataByDictKey("customLayerData", "loopStartToEndTimeCode", False)

    if parserOut.preferredIblVersion != -1:
        appleDict = usdStage.GetMetadataByDictKey("customLayerData", "Apple")
        if not isinstance(appleDict, dict):
            appleDict = {}
        appleDict["preferredIblVersion"] = parserOut.preferredIblVersion
        usdStage.SetMetadataByDictKey("customLayerData", "Apple", appleDict)

    rootPrim = usdStage.GetDefaultPrim() if usdStage.HasDefaultPrim() else None

    if rootPrim:
        params.assetName = rootPrim.GetName()
        params.materialsPath = f'/{params.assetName}/Materials'

    metersPerUnit = openParameters.metersPerUnit
    if parserOut.metersPerUnit != 0:
        metersPerUnit = parserOut.metersPerUnit
    if metersPerUnit == 0:
        metersPerUnit = 0.01
    if not legacyModifier:
        usdStage.SetMetadata("metersPerUnit", metersPerUnit)
    else:
        if rootPrim:
            usdMetersPerUnit = 0.01
            scale = metersPerUnit / usdMetersPerUnit
            if scale != 1:
                rootXform = UsdGeom.Xform(rootPrim)
                rootXform.AddScaleOp(UsdGeom.XformOp.PrecisionFloat, "metersPerUnit").Set(
                    Gf.Vec3f(scale, scale, scale)
                )

    getAllUsdMaterials(params, params.usdStage.GetPseudoRoot())

    if srcIsUsd and dstIsUsdz:
        # copy textures to temporary folder while creating usdz
        copyTexturesFromStageToFolder(params, srcPath, tmpFolder)

    if srcIsUsd:
        if not (len(parserOut.materials) == 1 and parserOut.materials[0].isEmpty()):
            usdUtils.printWarning(
                'Material arguments are ignored for .usda/usdc input files.'
            )
    else:
        # update usd materials with command line material arguments
        for material in parserOut.materials:
            if legacyModifier:
                legacyModifier.opacityAndDiffuseOneTexture(material)

            if material.name == '':
                # if materials are not specified, then apply default material to all materials
                if not material.isEmpty():
                    addDefaultMaterialToGeometries(params, params.usdStage.GetPseudoRoot())

                    copyMaterialTextures(params, material, srcPath, dstPath, tmpFolder)
                    if legacyModifier:
                        legacyModifier.makeORMTextures(material, tmpFolder, parserOut.verbose)

                    for path, usdMaterial in params.usdMaterials.items():
                        surfaceShader = material.getUsdSurfaceShader(usdMaterial, params.usdStage)
                        material.updateUsdMaterial(usdMaterial, surfaceShader, params.usdStage)
                continue

            usdMaterial = findUsdMaterial(
                params, material.path if material.path else material.name
            )

            if usdMaterial:
                # if material does exist remove it
                matPath = str(usdMaterial.GetPrim().GetPath())
                if matPath in params.usdMaterials:
                    del params.usdMaterials[matPath]
                usdStage.RemovePrim(matPath)
                usdMaterial = None

            copyMaterialTextures(params, material, srcPath, dstPath, tmpFolder)
            if legacyModifier:
                legacyModifier.makeORMTextures(material, tmpFolder, parserOut.verbose)

            usdMaterial = material.makeUsdMaterial(params.asset)
            if not usdMaterial:
                continue

            surfaceShader = material.getUsdSurfaceShader(usdMaterial, params.usdStage)
            material.updateUsdMaterial(usdMaterial, surfaceShader, params.usdStage)
            params.usdMaterials[str(usdMaterial.GetPrim().GetPath())] = usdMaterial

    usdStage.GetRootLayer().Export(str(tmpPath))

    # Prepare destination folder
    dstFolder = Path(dstPath).parent
    if dstFolder and not dstFolder.is_dir():
        if parserOut.verbose:
            print(f'Creating folder: {dstFolder}')
        dstFolder.mkdir(parents=True, exist_ok=True)

    if dstIsUsdz:
        # Construct .usdz archive from the .usdc file
        UsdUtils.CreateNewARKitUsdzPackage(Sdf.AssetPath(str(tmpPath)), str(dstPath))
    else:
        usdUtils.copy(str(tmpPath), str(dstPath))

    # Copy textures with usda and usdc
    if openParameters.copyTextures:
        copyTexturesFromStageToFolder(params, str(tmpPath), str(dstFolder))

    rmtree(tmpFolder, ignore_errors=True)
    print(f'Output file: {dstPath}')

    arkitCheckerReturn = 0
    if dstIsUsdz:
        # ARKit checker code
        usdcheckerArgs = [str(dstPath)]
        if parserOut.verbose:
            usdcheckerArgs.append('-v')
        scriptFolder = Path(__file__).parent
        spec = importlib.util.spec_from_loader(
            "usdARKitChecker",
            scriptFolder / 'usdARKitChecker',
        )
        usdARKitChecker = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(usdARKitChecker)
        arkitCheckerReturn = usdARKitChecker.main(usdcheckerArgs)

    return arkitCheckerReturn


def tryProcess(argumentList: List[str]) -> int:
    try:
        ret = process(argumentList)
    except usdUtils.ConvertError:
        return kConvertErrorReturnValue
    except usdUtils.ConvertExit:
        return 0
    except Exception as e:
        print(f'Unexpected error: {e}', file=sys.stderr)
        raise
    return ret


def convert(fileList: List[str], optionDictionary: Dict[str, Any]) -> int:
    supportedFormats = {'.obj', '.gltf', '.glb', '.fbx', '.usd', '.usda', '.usdc', '.usdz', '.abc'}
    argumentList: List[str] = []

    for file in fileList:
        filePath = Path(file)
        if filePath.suffix.lower() in supportedFormats:
            # source file to convert
            argumentList.append(str(filePath))

        name = filePath.stem

        for inputName in usdUtils.Input.names:
            if inputName in optionDictionary:
                option = optionDictionary[inputName]

                channel = ''

                optionAndChannel = option.split(':')
                if len(optionAndChannel) == 2:
                    option, channel = optionAndChannel

                if len(name) > len(option) and name.endswith(option):
                    argumentList.append(f'-{inputName}')
                    if channel:
                        argumentList.append(channel)
                    argumentList.append(str(filePath))

    return tryProcess(argumentList)


def main() -> int:
    return tryProcess(sys.argv[1:])


if __name__ == '__main__':
    if usdLibLoaded:
        errorValue = main()
    else:
        errorValue = kConvertErrorReturnValue

    sys.exit(errorValue)


def process(argumentList: List[str]) -> int:
    parser = Parser()
    parserOut = parser.parse(argumentList)

    srcPath = ''
    inFile = Path(parserOut.inFilePath)
    if inFile.is_file():
        srcPath = str(inFile)
    elif not inFile.parent and parserOut.argumentFile:
        argumentFileDir = Path(parserOut.argumentFile).parent
        os.chdir(argumentFileDir)
        if inFile.is_file():
            srcPath = str(inFile)

    if not srcPath:
        parser.printErrorUsageAndExit(f'input file {parserOut.inFilePath} does not exist.')

    fileAndExt = inFile.suffix
    if not fileAndExt:
        parser.printErrorUsageAndExit(
            f'input file {parserOut.inFilePath} has unsupported file extension.'
        )

    print(f'Input file: {srcPath}')
    srcExt = fileAndExt.lower()

    dstIsUsdz = False
    dstPath = Path(parserOut.outFilePath) if parserOut.outFilePath else Path(inFile.with_suffix('.usdz'))
    dstExt = dstPath.suffix.lower()

    if not dstPath.suffix:
        dstPath = dstPath.with_suffix('.usdz')
        dstIsUsdz = True
    elif dstExt == '.usdz':
        dstIsUsdz = True
    elif dstExt not in {'.usd', '.usdc', '.usda'}:
        parser.printErrorUsageAndExit(
            f'output file {dstPath} should have .usdz, .usdc, .usda or .usd extension.'
        )

    tmpFolder = tempfile.mkdtemp(prefix='usdzconvert')

    legacyModifier = None
    if parserOut.iOS12:
        iOS12Compatible_module = importlib.import_module("iOS12LegacyModifier")
        legacyModifier = iOS12Compatible_module.createLegacyModifier()
        print('Converting in iOS12 compatibility mode.')

    tmpPath = Path(tmpFolder) / (dstPath.with_suffix('.usdc').name if dstIsUsdz else dstPath.name)

    if parserOut.verbose and parserOut.copyTextures and dstIsUsdz:
        usdUtils.printWarning(
            'argument -copytextures works for .usda and .usdc output files only.'
        )

    openParameters = OpenParameters()
    openParameters.copyTextures = parserOut.copyTextures and not dstIsUsdz
    openParameters.searchPaths = parserOut.paths
    openParameters.verbose = parserOut.verbose

    srcIsUsd = False
    srcIsUsdz = False
    usdStage = None

    if srcExt == '.obj':
        usdStageWithObj_module = importlib.import_module("usdStageWithObj")
        usdStage = usdStageWithObj_module.usdStageWithObj(
            srcPath, str(tmpPath), parserOut.useObjMtl, openParameters
        )
    elif srcExt in {'.gltf', '.glb'}:
        usdStageWithGlTF_module = importlib.import_module("usdStageWithGlTF")
        usdStage = usdStageWithGlTF_module.usdStageWithGlTF(
            srcPath, str(tmpPath), legacyModifier, openParameters
        )
    elif srcExt == '.fbx':
        usdStageWithFbx_module = importlib.import_module("usdStageWithFbx")
        usdStage = usdStageWithFbx_module.usdStageWithFbx(
            srcPath, str(tmpPath), legacyModifier, openParameters
        )
    elif srcExt in {'.usd', '.usda', '.usdc'}:
        usdStage = Usd.Stage.Open(srcPath)
        srcIsUsd = True
        openParameters.metersPerUnit = usdStage.GetMetadata("metersPerUnit")
    elif srcExt == '.usdz':
        tmpUSDC = unzip(srcPath, tmpFolder)
        if not tmpUSDC:
            parser.printErrorUsageAndExit(f"can't open input usdz file {parserOut.inFilePath}")
        usdStage = Usd.Stage.Open(Path(tmpFolder) / tmpUSDC)
        srcIsUsdz = True
    elif srcExt == '.abc':
        usdStage = Usd.Stage.Open(srcPath)
        # To update Alembic USD Stage, first save it to temporary .usdc and reload it
        tmpUSDC = str(tmpPath) + '.usdc'
        usdStage.GetRootLayer().Export(tmpUSDC)
        if parserOut.verbose:
            print(f'Temporary USDC file: {tmpUSDC}')
        usdStage = Usd.Stage.Open(tmpUSDC)
    else:
        parser.printErrorUsageAndExit(
            f'input file {parserOut.inFilePath} has unsupported file extension.'
        )

    if not usdStage:
        usdUtils.printError("failed to create USD stage.")
        raise usdUtils.ConvertError()

    params = USDParameters(
        usdStage,
        parserOut.verbose,
        parserOut.url,
        parserOut.creator,
        parserOut.copyright,
        str(tmpPath),
    )
    createStageMetadata(params)

    if parserOut.loop and srcIsUsd or srcIsUsdz:
        usdStage.SetMetadataByDictKey("customLayerData", "loopStartToEndTimeCode", True)

    if parserOut.noloop:
        usdStage.SetMetadataByDictKey("customLayerData", "loopStartToEndTimeCode", False)

    if parserOut.preferredIblVersion != -1:
        appleDict = usdStage.GetMetadataByDictKey("customLayerData", "Apple")
        if not isinstance(appleDict, dict):
            appleDict = {}
        appleDict["preferredIblVersion"] = parserOut.preferredIblVersion
        usdStage.SetMetadataByDictKey("customLayerData", "Apple", appleDict)

    rootPrim = usdStage.GetDefaultPrim() if usdStage.HasDefaultPrim() else None

    if rootPrim:
        params.assetName = rootPrim.GetName()
        params.materialsPath = f'/{params.assetName}/Materials'

    metersPerUnit = openParameters.metersPerUnit
    if parserOut.metersPerUnit != 0:
        metersPerUnit = parserOut.metersPerUnit
    if metersPerUnit == 0:
        metersPerUnit = 0.01
    if not legacyModifier:
        usdStage.SetMetadata("metersPerUnit", metersPerUnit)
    else:
        if rootPrim:
            usdMetersPerUnit = 0.01
            scale = metersPerUnit / usdMetersPerUnit
            if scale != 1:
                rootXform = UsdGeom.Xform(rootPrim)
                rootXform.AddScaleOp(UsdGeom.XformOp.PrecisionFloat, "metersPerUnit").Set(
                    Gf.Vec3f(scale, scale, scale)
                )

    getAllUsdMaterials(params, params.usdStage.GetPseudoRoot())

    if srcIsUsd and dstIsUsdz:
        # copy textures to temporary folder while creating usdz
        copyTexturesFromStageToFolder(params, srcPath, tmpFolder)

    if srcIsUsd:
        if not (len(parserOut.materials) == 1 and parserOut.materials[0].isEmpty()):
            usdUtils.printWarning(
                'Material arguments are ignored for .usda/usdc input files.'
            )
    else:
        # update usd materials with command line material arguments
        for material in parserOut.materials:
            if legacyModifier:
                legacyModifier.opacityAndDiffuseOneTexture(material)

            if material.name == '':
                # if materials are not specified, then apply default material to all materials
                if not material.isEmpty():
                    addDefaultMaterialToGeometries(params, params.usdStage.GetPseudoRoot())

                    copyMaterialTextures(params, material, srcPath, dstPath, tmpFolder)
                    if legacyModifier:
                        legacyModifier.makeORMTextures(material, tmpFolder, parserOut.verbose)

                    for path, usdMaterial in params.usdMaterials.items():
                        surfaceShader = material.getUsdSurfaceShader(usdMaterial, params.usdStage)
                        material.updateUsdMaterial(usdMaterial, surfaceShader, params.usdStage)
                continue

            usdMaterial = findUsdMaterial(
                params, material.path if material.path else material.name
            )

            if usdMaterial:
                # if material does exist remove it
                matPath = str(usdMaterial.GetPrim().GetPath())
                if matPath in params.usdMaterials:
                    del params.usdMaterials[matPath]
                usdStage.RemovePrim(matPath)
                usdMaterial = None

            copyMaterialTextures(params, material, srcPath, dstPath, tmpFolder)
            if legacyModifier:
                legacyModifier.makeORMTextures(material, tmpFolder, parserOut.verbose)

            usdMaterial = material.makeUsdMaterial(params.asset)
            if not usdMaterial:
                continue

            surfaceShader = material.getUsdSurfaceShader(usdMaterial, params.usdStage)
            material.updateUsdMaterial(usdMaterial, surfaceShader, params.usdStage)
            params.usdMaterials[str(usdMaterial.GetPrim().GetPath())] = usdMaterial

    usdStage.GetRootLayer().Export(str(tmpPath))

    # Prepare destination folder
    dstFolder = Path(dstPath).parent
    if dstFolder and not dstFolder.is_dir():
        if parserOut.verbose:
            print(f'Creating folder: {dstFolder}')
        dstFolder.mkdir(parents=True, exist_ok=True)

    if dstIsUsdz:
        # Construct .usdz archive from the .usdc file
        UsdUtils.CreateNewARKitUsdzPackage(Sdf.AssetPath(str(tmpPath)), str(dstPath))
    else:
        usdUtils.copy(str(tmpPath), str(dstPath))

    # Copy textures with usda and usdc
    if openParameters.copyTextures:
        copyTexturesFromStageToFolder(params, str(tmpPath), str(dstFolder))

    rmtree(tmpFolder, ignore_errors=True)
    print(f'Output file: {dstPath}')

    arkitCheckerReturn = 0
    if dstIsUsdz:
        # ARKit checker code
        usdcheckerArgs = [str(dstPath)]
        if parserOut.verbose:
            usdcheckerArgs.append('-v')
        scriptFolder = Path(__file__).parent
        spec = importlib.util.spec_from_loader(
            "usdARKitChecker",
            scriptFolder / 'usdARKitChecker',
        )
        usdARKitChecker = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(usdARKitChecker)
        arkitCheckerReturn = usdARKitChecker.main(usdcheckerArgs)

    return arkitCheckerReturn


def tryProcess(argumentList: List[str]) -> int:
    try:
        ret = process(argumentList)
    except usdUtils.ConvertError:
        return kConvertErrorReturnValue
    except usdUtils.ConvertExit:
        return 0
    except Exception as e:
        print(f'Unexpected error: {e}', file=sys.stderr)
        raise
    return ret


def convert(fileList: List[str], optionDictionary: Dict[str, Any]) -> int:
    supportedFormats = {'.obj', '.gltf', '.glb', '.fbx', '.usd', '.usda', '.usdc', '.usdz', '.abc'}
    argumentList: List[str] = []

    for file in fileList:
        filePath = Path(file)
        if filePath.suffix.lower() in supportedFormats:
            # source file to convert
            argumentList.append(str(filePath))

        name = filePath.stem

        for inputName in usdUtils.Input.names:
            if inputName in optionDictionary:
                option = optionDictionary[inputName]

                channel = ''

                optionAndChannel = option.split(':')
                if len(optionAndChannel) == 2:
                    option, channel = optionAndChannel

                if len(name) > len(option) and name.endswith(option):
                    argumentList.append(f'-{inputName}')
                    if channel:
                        argumentList.append(channel)
                    argumentList.append(str(filePath))

    return tryProcess(argumentList)


def main() -> int:
    return tryProcess(sys.argv[1:])


if __name__ == '__main__':
    if usdLibLoaded:
        errorValue = main()
    else:
        errorValue = kConvertErrorReturnValue

    sys.exit(errorValue)

